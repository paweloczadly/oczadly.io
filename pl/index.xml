<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>oczadly.io - production-ready tooling. Clean solutions.</title><link>https://oczadly.io/pl/</link><description>Patterns for platform engineering and AI workflows.</description><generator>Hugo -- gohugo.io</generator><language>pl</language><managingEditor>p@oczadly.io (Paweł Oczadły)</managingEditor><webMaster>p@oczadly.io (Paweł Oczadły)</webMaster><lastBuildDate>Fri, 26 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://oczadly.io/pl/index.xml" rel="self" type="application/rss+xml"/><item><title>Azure IaC zbudowana dla Twoich potrzeb</title><link>https://oczadly.io/pl/posts/2025-09-26-azure-iac-built-for-your-needs/</link><pubDate>Fri, 26 Sep 2025 00:00:00 +0000</pubDate><author>Paweł Oczadły</author><guid>https://oczadly.io/pl/posts/2025-09-26-azure-iac-built-for-your-needs/</guid><description>&lt;p>Przez lata pracy miałem okazję uczestniczyć w wielu projektach i widzieć różne podejścia do organizacji infrastruktury jako kod przy użyciu &lt;a href="https://developer.hashicorp.com/terraform" target="_blank" rel="noopener noreffer ">Terraforma&lt;/a>. Niektóre z nich działały lepiej, inne gorzej. Część świetnie sprawdzała się na początku, ale w miarę rozwoju projektu — przy dodawaniu nowych zasobów pod presją czasu i priorytetów organizacji — kod stawał się trudny w utrzymaniu. Infrastruktura nadal była zapisana w kodzie, ale każda zmiana zajmowała więcej czasu, a refaktoryzacja przestawała być opłacalna.&lt;/p></description></item><item><title>gradle init dla Spring Boot</title><link>https://oczadly.io/pl/posts/2025-08-28-gradle-init-for-spring-boot/</link><pubDate>Thu, 28 Aug 2025 00:00:00 +0000</pubDate><author>Paweł Oczadły</author><guid>https://oczadly.io/pl/posts/2025-08-28-gradle-init-for-spring-boot/</guid><description><![CDATA[<h2 id="dlaczego-kolejny-plugin-gradle">Dlaczego kolejny plugin Gradle</h2>
<p>Ostatnio chciałem poszerzyć swoją wiedzę o <a href="https://docs.gradle.org/9.0.0/userguide/build_scans.html" target="_blank" rel="noopener noreffer ">Build Scanach</a>, <a href="https://gradle.com/develocity/" target="_blank" rel="noopener noreffer ">Develocity</a> i ich praktycznym zastosowaniu, dlatego zacząłem przerabiać kursy na naszej platformie <a href="https://dpeuniversity.gradle.com/app/catalog" target="_blank" rel="noopener noreffer ">DPE University</a>. Na co dzień mam styczność z <a href="https://gradle.com/develocity/" target="_blank" rel="noopener noreffer ">Develocity</a> od strony operacyjnej i produkcyjnej – utrzymuję między innymi <a href="https://github.com/gradle/develocity-oss-projects" target="_blank" rel="noopener noreffer ">instancje open source</a>, więc zależało mi na lepszym zrozumieniu produktu, a zwłaszcza użycia od strony użytkowników, w mojej codziennej pracy inżyniera.</p>
<p>Aby usystematyzować zdobytą wiedzę, postanowiłem zbudować projekt zgodny z best practices omawianymi na kursach. Równolegle pracowałem nad mikroserwisem w <a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener noreffer ">Spring Boot</a>, generowanym ze <a href="https://start.spring.io/" target="_blank" rel="noopener noreffer ">Spring Initializr</a>, i zauważyłem brak <a href="https://docs.gradle.org/9.0.0/userguide/plugins.html" target="_blank" rel="noopener noreffer ">pluginu Gradle</a>, który automatyzowałby ten proces w sposób przyjazny build cache i CI/CD. W efekcie każdy nowy projekt wymagał ręcznej konfiguracji. Chciałem to uprościć i zbliżyć doświadczenie do znanego <code>gradle init</code> – ale w wersji dla <a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener noreffer ">Spring Boot</a>.</p>]]></description></item><item><title>Start bloga oczadly.io</title><link>https://oczadly.io/pl/posts/2025-07-05-starting-oczadly-io/</link><pubDate>Sat, 05 Jul 2025 00:00:00 +0000</pubDate><author>Paweł Oczadły</author><guid>https://oczadly.io/pl/posts/2025-07-05-starting-oczadly-io/</guid><description><![CDATA[<p>Witaj na moim blogu!</p>
<p>Stworzyłem go, aby dokumentować i dzielić się swoimi osobistymi doświadczeniami w budowaniu rozwiązań z zakresu architektury chmurowej, platform engineeringu oraz AI-native tooling.</p>
<p>Blog będzie pełnił rolę mojego <strong>osobistego notesu inżynierskiego</strong> – miejsca, w którym zapisuję uporządkowane lekcje, wzorce i decyzje w sposób przejrzysty i dostępny.</p>
<hr>
<h2 id="czego-możesz-się-spodziewać">Czego możesz się spodziewać</h2>
<ul>
<li>Praktycznych wpisów skupionych na implementacji.</li>
<li>Uporządkowanych wzorców do budowania skalowalnych platform.</li>
<li>Insightów dotyczących Gradle, OpenTofu, workflowów GitOps i AI-native systems.</li>
<li>Czystych, minimalistycznych, pozbawionych szumu treści.</li>
</ul>
<hr>
<h2 id="zaczynamy">Zaczynamy</h2>
<p>Żeby nie zostawiać Cię z samym powitaniem i zapowiedzą, co będzie na blogu, przedstawiam, jak uruchomiony jest ten blog. <strong>W pełni automatycznie i w sposób deklaratywny</strong>. W myśl z jednej moich ulubionych zasad:</p>]]></description></item></channel></rss>